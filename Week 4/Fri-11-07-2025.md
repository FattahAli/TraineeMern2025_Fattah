# React Hooks 



## `useState()`

**Purpose:**  
Manages local component state.

**Example Use Case:**  
Storing and updating items in a **shopping cart**.

```js
const [cartItems, setCartItems] = useState([]);
```

---

##  `useReducer()`

**Purpose:**  
Handles complex state logic or multiple state variables, especially when the next state depends on the previous one.

**Example Use Cases:**
- Managing **multiple inputs** in a form  
- Controlling game state like in **Pac-Man**

```js
const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    default:
      return state;
  }
}

const [state, dispatch] = useReducer(reducer, initialState);
```

---

## `useContext()`

**Purpose:**  
Allows sharing data (context) globally across components without prop drilling.

**Example Use Case:**  
Sharing **user authentication data** or **theme settings** across your app.

```js
const ThemeContext = React.createContext();
const theme = useContext(ThemeContext);
```

---

## `useRef()`

**Purpose:**  
Stores a mutable value that does not cause re-render on change.  
Also used to directly reference a DOM element.

**Example Use Cases:**  
- Storing a **timer ID**
- Focusing an **input field**

```js
const inputRef = useRef(null);
inputRef.current.focus();
```

---

## `useEffect()`

**Purpose:**  
Runs side effects like data fetching, subscriptions, or manual DOM manipulation.  
Can run on **mount**, **update**, or **dependency change**.

**Example Use Case:**  
Updating the DOM when a **counter changes**.

```js
useEffect(() => {
  console.log('Counter updated:', count);
}, [count]);
```

---

##  `useMemo()`

**Purpose:**  
**Memoizes** a computed value so it's only recalculated when dependencies change.  
Helps optimize performance for expensive calculations.

**Example Use Case:**  
Caching filtered or sorted data.

```js
const sortedItems = useMemo(() => {
  return items.sort((a, b) => a.value - b.value);
}, [items]);
```

---

##  `useCallback()`

**Purpose:**  
Returns a **memoized version of a callback function**.  
Prevents function recreation on every render (useful when passing props to child components).

**Example Use Case:**  
Optimizing **callback performance** in memoized child components.

```js
const handleClick = useCallback(() => {
  console.log('Clicked!');
}, []);
```

---

**Use `useMemo` for **values** and `useCallback` for **functions** you want to memoize.**